package ike

import (
	"encoding/hex"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/free5gc/ike/message"
	"github.com/free5gc/ike/security"
	"github.com/free5gc/ike/security/encr"
	"github.com/free5gc/ike/security/integ"
)

func TestEncodeDecode(t *testing.T) {
	encryptionAlgorithm := encr.StrToType("ENCR_AES_CBC_256")

	integrityAlgorithm := integ.StrToType("AUTH_HMAC_SHA1_96")

	ikeSAKey := &security.IKESAKey{
		EncrInfo:  encryptionAlgorithm,
		IntegInfo: integrityAlgorithm,
	}

	var err error
	ikeSAKey.SK_ei, err = hex.DecodeString(
		"3d7a26417122cee9" +
			"c77c59f375b024cd" +
			"b9f0b5777ea18b50" +
			"f8a671fd3b2daa99")
	require.NoError(t, err)
	ikeSAKey.Encr_i, err = ikeSAKey.EncrInfo.NewCrypto(ikeSAKey.SK_ei)
	require.NoError(t, err)

	ikeSAKey.SK_er, err = hex.DecodeString(
		"3ea57e7ddfb30756" +
			"a04619a9873333b0" +
			"8e94deef05b6a05d" +
			"7eb3dba075d81c6f")
	require.NoError(t, err)
	ikeSAKey.Encr_r, err = ikeSAKey.EncrInfo.NewCrypto(ikeSAKey.SK_er)
	require.NoError(t, err)

	ikeSAKey.SK_ai, err = hex.DecodeString(
		"ab8047415535cf53" +
			"e19a69e2c86feadf" +
			"ebfff1e9")
	require.NoError(t, err)
	ikeSAKey.Integ_i = ikeSAKey.IntegInfo.Init(ikeSAKey.SK_ai)

	ikeSAKey.SK_ar, err = hex.DecodeString(
		"16d5ae6f2859a73a" +
			"8c7db60bed07e245" +
			"38b19bb0")
	require.NoError(t, err)
	ikeSAKey.Integ_r = ikeSAKey.IntegInfo.Init(ikeSAKey.SK_ar)

	expIkeMsg := &message.IKEMessage{
		InitiatorSPI: 0x000000000006f708,
		ResponderSPI: 0xc9e2e31f8b64053d,
		MajorVersion: 2,
		MinorVersion: 0,
		ExchangeType: message.IKE_AUTH,
		Flags:        0x08,
		MessageID:    0x03,
	}

	expIkePayloads := message.IKEPayloadContainer{
		&message.EAP{
			Code:       0x02,
			Identifier: 0x3b,
			EAPTypeData: message.EAPTypeDataContainer{
				&message.EAPExpanded{
					VendorID:   0x28af,
					VendorType: 0x03,
					VendorData: []byte{
						0x02, 0x00, 0x00, 0x00, 0x00, 0x15, 0x7e, 0x00,
						0x57, 0x2d, 0x10, 0xf5, 0x07, 0x36, 0x2e, 0x32,
						0x2d, 0xe3, 0x68, 0x57, 0x93, 0x65, 0xd2, 0x86,
						0x2b, 0x50, 0xed,
					},
				},
			},
		},
	}

	expIkeMsg.Payloads = append(expIkeMsg.Payloads, expIkePayloads...)

	b, err := EncodeEncrypt(expIkeMsg, ikeSAKey, message.Role_Initiator)
	require.NoError(t, err)

	ikeMsg, err := DecodeDecrypt(b, ikeSAKey, message.Role_Responder)
	require.NoError(t, err)

	require.Equal(t, expIkePayloads, ikeMsg.Payloads)
}

func TestDecodeDecrypt(t *testing.T) {
	testcases := []struct {
		description                string
		b                          []byte
		ikeSAKey                   *security.IKESAKey
		sk_ei, sk_er, sk_ai, sk_ar []byte
		expErr                     bool
		expIkeMsg                  *message.IKEMessage
	}{
		{
			description: "decrypt with key",
			b: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf7, 0x08,
				0xc9, 0xe2, 0xe3, 0x1f, 0x8b, 0x64, 0x05, 0x3d,
				0x2e, 0x20, 0x23, 0x08, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x6c, 0x30, 0x00, 0x00, 0x50,
				0xec, 0x50, 0x31, 0x16, 0x2c, 0x69, 0x2f, 0xbb,
				0xfc, 0x4d, 0x20, 0x64, 0x0c, 0x91, 0x21, 0xeb,
				0xe9, 0x47, 0x5e, 0xf9, 0x4f, 0x9b, 0x02, 0x95,
				0x9d, 0x31, 0x24, 0x2e, 0x53, 0x5e, 0x9c, 0x3c,
				0x4d, 0xca, 0xec, 0xd1, 0xbf, 0xd6, 0xdd, 0x80,
				0xaa, 0x81, 0x2b, 0x07, 0xde, 0x36, 0xde, 0xe9,
				0xb7, 0x50, 0x94, 0x35, 0xf6, 0x35, 0xe1, 0xaa,
				0xae, 0x1c, 0x38, 0x25, 0xf4, 0xea, 0xe3, 0x38,
				0x49, 0x03, 0xf7, 0x24, 0xf4, 0x44, 0x17, 0x0c,
				0x68, 0x45, 0xca, 0x80,
			},
			ikeSAKey: &security.IKESAKey{
				EncrInfo:  encr.StrToType("ENCR_AES_CBC_256"),
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			sk_ei: []byte{
				0x3d, 0x7a, 0x26, 0x41, 0x71, 0x22, 0xce, 0xe9,
				0xc7, 0x7c, 0x59, 0xf3, 0x75, 0xb0, 0x24, 0xcd,
				0xb9, 0xf0, 0xb5, 0x77, 0x7e, 0xa1, 0x8b, 0x50,
				0xf8, 0xa6, 0x71, 0xfd, 0x3b, 0x2d, 0xaa, 0x99,
			},
			sk_er: []byte{
				0x3e, 0xa5, 0x7e, 0x7d, 0xdf, 0xb3, 0x07, 0x56,
				0xa0, 0x46, 0x19, 0xa9, 0x87, 0x33, 0x33, 0xb0,
				0x8e, 0x94, 0xde, 0xef, 0x05, 0xb6, 0xa0, 0x5d,
				0x7e, 0xb3, 0xdb, 0xa0, 0x75, 0xd8, 0x1c, 0x6f,
			},
			sk_ai: []byte{
				0xab, 0x80, 0x47, 0x41, 0x55, 0x35, 0xcf, 0x53,
				0xe1, 0x9a, 0x69, 0xe2, 0xc8, 0x6f, 0xea, 0xdf,
				0xeb, 0xff, 0xf1, 0xe9,
			},
			sk_ar: []byte{
				0x16, 0xd5, 0xae, 0x6f, 0x28, 0x59, 0xa7, 0x3a,
				0x8c, 0x7d, 0xb6, 0x0b, 0xed, 0x07, 0xe2, 0x45,
				0x38, 0xb1, 0x9b, 0xb0,
			},
			expErr: false,
			expIkeMsg: &message.IKEMessage{
				InitiatorSPI: 0x000000000006f708,
				ResponderSPI: 0xc9e2e31f8b64053d,
				MajorVersion: 2,
				MinorVersion: 0,
				ExchangeType: message.IKE_AUTH,
				Flags:        0x08,
				MessageID:    0x03,
				Payloads: message.IKEPayloadContainer{
					&message.EAP{
						Code:       0x02,
						Identifier: 0x3b,
						EAPTypeData: []message.EAPTypeFormat{
							&message.EAPExpanded{
								VendorID:   0x28af,
								VendorType: 0x03,
								VendorData: []byte{
									0x02, 0x00, 0x00, 0x00, 0x00, 0x15, 0x7e, 0x00,
									0x57, 0x2d, 0x10, 0xf5, 0x07, 0x36, 0x2e, 0x32,
									0x2d, 0xe3, 0x68, 0x57, 0x93, 0x65, 0xd2, 0x86,
									0x2b, 0x50, 0xed,
								},
							},
						},
					},
				},
			},
		},
		{
			description: "decrypt without key",
			b: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf7, 0x08,
				0xc9, 0xe2, 0xe3, 0x1f, 0x8b, 0x64, 0x05, 0x3d,
				0x2e, 0x20, 0x23, 0x08, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x6c, 0x30, 0x00, 0x00, 0x50,
				0xec, 0x50, 0x31, 0x16, 0x2c, 0x69, 0x2f, 0xbb,
				0xfc, 0x4d, 0x20, 0x64, 0x0c, 0x91, 0x21, 0xeb,
				0xe9, 0x47, 0x5e, 0xf9, 0x4f, 0x9b, 0x02, 0x95,
				0x9d, 0x31, 0x24, 0x2e, 0x53, 0x5e, 0x9c, 0x3c,
				0x4d, 0xca, 0xec, 0xd1, 0xbf, 0xd6, 0xdd, 0x80,
				0xaa, 0x81, 0x2b, 0x07, 0xde, 0x36, 0xde, 0xe9,
				0xb7, 0x50, 0x94, 0x35, 0xf6, 0x35, 0xe1, 0xaa,
				0xae, 0x1c, 0x38, 0x25, 0xf4, 0xea, 0xe3, 0x38,
				0x49, 0x03, 0xf7, 0x24, 0xf4, 0x44, 0x17, 0x0c,
				0x68, 0x45, 0xca, 0x80,
			},
			expErr: true,
		},
		{
			description: "msg len less than 28",
			b:           []byte{},
			expErr:      true,
		},
		{
			description: "no sk_ai",
			b: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf7, 0x08,
				0xc9, 0xe2, 0xe3, 0x1f, 0x8b, 0x64, 0x05, 0x3d,
				0x2e, 0x20, 0x23, 0x08, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x6c, 0x30, 0x00, 0x00, 0x50,
				0xec, 0x50, 0x31, 0x16, 0x2c, 0x69, 0x2f, 0xbb,
				0xfc, 0x4d, 0x20, 0x64, 0x0c, 0x91, 0x21, 0xeb,
				0xe9, 0x47, 0x5e, 0xf9, 0x4f, 0x9b, 0x02, 0x95,
				0x9d, 0x31, 0x24, 0x2e, 0x53, 0x5e, 0x9c, 0x3c,
				0x4d, 0xca, 0xec, 0xd1, 0xbf, 0xd6, 0xdd, 0x80,
				0xaa, 0x81, 0x2b, 0x07, 0xde, 0x36, 0xde, 0xe9,
				0xb7, 0x50, 0x94, 0x35, 0xf6, 0x35, 0xe1, 0xaa,
				0xae, 0x1c, 0x38, 0x25, 0xf4, 0xea, 0xe3, 0x38,
				0x49, 0x03, 0xf7, 0x24, 0xf4, 0x44, 0x17, 0x0c,
				0x68, 0x45, 0xca, 0x80,
			},
			ikeSAKey: &security.IKESAKey{
				EncrInfo:  encr.StrToType("ENCR_AES_CBC_256"),
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			sk_ei: []byte{
				0x3d, 0x7a, 0x26, 0x41, 0x71, 0x22, 0xce, 0xe9,
				0xc7, 0x7c, 0x59, 0xf3, 0x75, 0xb0, 0x24, 0xcd,
				0xb9, 0xf0, 0xb5, 0x77, 0x7e, 0xa1, 0x8b, 0x50,
				0xf8, 0xa6, 0x71, 0xfd, 0x3b, 0x2d, 0xaa, 0x99,
			},
			sk_er: []byte{
				0x3e, 0xa5, 0x7e, 0x7d, 0xdf, 0xb3, 0x07, 0x56,
				0xa0, 0x46, 0x19, 0xa9, 0x87, 0x33, 0x33, 0xb0,
				0x8e, 0x94, 0xde, 0xef, 0x05, 0xb6, 0xa0, 0x5d,
				0x7e, 0xb3, 0xdb, 0xa0, 0x75, 0xd8, 0x1c, 0x6f,
			},
			sk_ar: []byte{
				0x16, 0xd5, 0xae, 0x6f, 0x28, 0x59, 0xa7, 0x3a,
				0x8c, 0x7d, 0xb6, 0x0b, 0xed, 0x07, 0xe2, 0x45,
				0x38, 0xb1, 0x9b, 0xb0,
			},
			expErr: true,
		},
		{
			description: "no sk_ei",
			b: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf7, 0x08,
				0xc9, 0xe2, 0xe3, 0x1f, 0x8b, 0x64, 0x05, 0x3d,
				0x2e, 0x20, 0x23, 0x08, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x6c, 0x30, 0x00, 0x00, 0x50,
				0xec, 0x50, 0x31, 0x16, 0x2c, 0x69, 0x2f, 0xbb,
				0xfc, 0x4d, 0x20, 0x64, 0x0c, 0x91, 0x21, 0xeb,
				0xe9, 0x47, 0x5e, 0xf9, 0x4f, 0x9b, 0x02, 0x95,
				0x9d, 0x31, 0x24, 0x2e, 0x53, 0x5e, 0x9c, 0x3c,
				0x4d, 0xca, 0xec, 0xd1, 0xbf, 0xd6, 0xdd, 0x80,
				0xaa, 0x81, 0x2b, 0x07, 0xde, 0x36, 0xde, 0xe9,
				0xb7, 0x50, 0x94, 0x35, 0xf6, 0x35, 0xe1, 0xaa,
				0xae, 0x1c, 0x38, 0x25, 0xf4, 0xea, 0xe3, 0x38,
				0x49, 0x03, 0xf7, 0x24, 0xf4, 0x44, 0x17, 0x0c,
				0x68, 0x45, 0xca, 0x80,
			},
			ikeSAKey: &security.IKESAKey{
				EncrInfo:  encr.StrToType("ENCR_AES_CBC_256"),
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			sk_er: []byte{
				0x3e, 0xa5, 0x7e, 0x7d, 0xdf, 0xb3, 0x07, 0x56,
				0xa0, 0x46, 0x19, 0xa9, 0x87, 0x33, 0x33, 0xb0,
				0x8e, 0x94, 0xde, 0xef, 0x05, 0xb6, 0xa0, 0x5d,
				0x7e, 0xb3, 0xdb, 0xa0, 0x75, 0xd8, 0x1c, 0x6f,
			},
			sk_ai: []byte{
				0xab, 0x80, 0x47, 0x41, 0x55, 0x35, 0xcf, 0x53,
				0xe1, 0x9a, 0x69, 0xe2, 0xc8, 0x6f, 0xea, 0xdf,
				0xeb, 0xff, 0xf1, 0xe9,
			},
			sk_ar: []byte{
				0x16, 0xd5, 0xae, 0x6f, 0x28, 0x59, 0xa7, 0x3a,
				0x8c, 0x7d, 0xb6, 0x0b, 0xed, 0x07, 0xe2, 0x45,
				0x38, 0xb1, 0x9b, 0xb0,
			},
			expErr: true,
		},
		{
			description: "invalid checksum",
			b: []byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf7, 0x08,
				0xc9, 0xe2, 0xe3, 0x1f, 0x8b, 0x64, 0x05, 0x3d,
				0x2e, 0x20, 0x23, 0x08, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x6c, 0x30, 0x00, 0x00, 0x50,
				0xec, 0x50, 0x31, 0x16, 0x2c, 0x69, 0x2f, 0xbb,
				0xfc, 0x4d, 0x20, 0x64, 0x0c, 0x91, 0x21, 0xeb,
				0xe9, 0x47, 0x5e, 0xf9, 0x4f, 0x9b, 0x02, 0x95,
				0x9d, 0x31, 0x24, 0x2e, 0x53, 0x5e, 0x9c, 0x3c,
				0x4d, 0xca, 0xec, 0xd1, 0xbf, 0xd6, 0xdd, 0x80,
				0xaa, 0x81, 0x2b, 0x07, 0xde, 0x36, 0xde, 0xe9,
				0xb7, 0x50, 0x94, 0x35, 0xf6, 0x35, 0xe1, 0xaa,
				0xae, 0x1c, 0x38, 0x25, 0xf4, 0xea, 0xe3, 0x38,
				0x49, 0x03, 0xf7, 0x24, 0xf4, 0x44, 0x17, 0x0c,
				0x00, 0x00, 0x00, 0x00,
			},
			ikeSAKey: &security.IKESAKey{
				EncrInfo:  encr.StrToType("ENCR_AES_CBC_256"),
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			sk_ei: []byte{
				0x3d, 0x7a, 0x26, 0x41, 0x71, 0x22, 0xce, 0xe9,
				0xc7, 0x7c, 0x59, 0xf3, 0x75, 0xb0, 0x24, 0xcd,
				0xb9, 0xf0, 0xb5, 0x77, 0x7e, 0xa1, 0x8b, 0x50,
				0xf8, 0xa6, 0x71, 0xfd, 0x3b, 0x2d, 0xaa, 0x99,
			},
			sk_er: []byte{
				0x3e, 0xa5, 0x7e, 0x7d, 0xdf, 0xb3, 0x07, 0x56,
				0xa0, 0x46, 0x19, 0xa9, 0x87, 0x33, 0x33, 0xb0,
				0x8e, 0x94, 0xde, 0xef, 0x05, 0xb6, 0xa0, 0x5d,
				0x7e, 0xb3, 0xdb, 0xa0, 0x75, 0xd8, 0x1c, 0x6f,
			},
			sk_ai: []byte{
				0xab, 0x80, 0x47, 0x41, 0x55, 0x35, 0xcf, 0x53,
				0xe1, 0x9a, 0x69, 0xe2, 0xc8, 0x6f, 0xea, 0xdf,
				0xeb, 0xff, 0xf1, 0xe9,
			},
			sk_ar: []byte{
				0x16, 0xd5, 0xae, 0x6f, 0x28, 0x59, 0xa7, 0x3a,
				0x8c, 0x7d, 0xb6, 0x0b, 0xed, 0x07, 0xe2, 0x45,
				0x38, 0xb1, 0x9b, 0xb0,
			},
			expErr: true,
		},
	}

	var err error

	for _, tc := range testcases {
		t.Run(tc.description, func(t *testing.T) {
			if len(tc.sk_ai) > 0 {
				tc.ikeSAKey.Integ_i = tc.ikeSAKey.IntegInfo.Init(tc.sk_ai)
			}
			if len(tc.sk_ar) > 0 {
				tc.ikeSAKey.Integ_r = tc.ikeSAKey.IntegInfo.Init(tc.sk_ar)
			}

			if len(tc.sk_ei) > 0 {
				tc.ikeSAKey.Encr_i, err = tc.ikeSAKey.EncrInfo.NewCrypto(tc.sk_ei)
				require.NoError(t, err)
			}

			if len(tc.sk_er) > 0 {
				tc.ikeSAKey.Encr_r, err = tc.ikeSAKey.EncrInfo.NewCrypto(tc.sk_er)
				require.NoError(t, err)
			}

			ikeMsg, err := DecodeDecrypt(tc.b, tc.ikeSAKey, message.Role_Responder)
			if tc.expErr {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
			}
			require.Equal(t, tc.expIkeMsg, ikeMsg)
		})
	}
}

func TestEncryptMsg(t *testing.T) {
	encryptionAlgorithm := encr.StrToType("ENCR_AES_CBC_256")

	integrityAlgorithm := integ.StrToType("AUTH_HMAC_SHA1_96")

	ikeSAKey := &security.IKESAKey{
		EncrInfo:  encryptionAlgorithm,
		IntegInfo: integrityAlgorithm,
	}

	var err error
	sk_ei, err := hex.DecodeString(
		"3d7a26417122cee9c77c59f375b024cdb9f0b5777ea18b50f8a671fd3b2daa99")
	require.NoError(t, err)
	ikeSAKey.Encr_i, err = ikeSAKey.EncrInfo.NewCrypto(sk_ei)
	require.NoError(t, err)

	sk_er, err := hex.DecodeString(
		"3ea57e7ddfb30756a04619a9873333b08e94deef05b6a05d7eb3dba075d81c6f")
	require.NoError(t, err)
	ikeSAKey.Encr_r, err = ikeSAKey.EncrInfo.NewCrypto(sk_er)
	require.NoError(t, err)

	sk_ai, err := hex.DecodeString(
		"ab8047415535cf53e19a69e2c86feadfebfff1e9")
	require.NoError(t, err)
	ikeSAKey.Integ_i = ikeSAKey.IntegInfo.Init(sk_ai)

	sk_ar, err := hex.DecodeString(
		"16d5ae6f2859a73a8c7db60bed07e24538b19bb0")
	require.NoError(t, err)
	integ_r := ikeSAKey.IntegInfo.Init(sk_ar)
	ikeSAKey.Integ_r = integ_r

	ikeMessage := &message.IKEMessage{
		ResponderSPI: 0xc9e2e31f8b64053d,
		InitiatorSPI: 0x000000000006f708,
		MajorVersion: 2,
		MinorVersion: 0,
		ExchangeType: message.IKE_AUTH,
		Flags:        0x08,
		MessageID:    0x03,
	}

	ikePayloads := message.IKEPayloadContainer{
		&message.EAP{
			Code:       0x02,
			Identifier: 0x3b,
			EAPTypeData: message.EAPTypeDataContainer{
				&message.EAPExpanded{
					VendorID:   0x28af,
					VendorType: 0x03,
					VendorData: []byte{
						0x02, 0x00, 0x00, 0x00, 0x00, 0x15, 0x7e, 0x00,
						0x57, 0x2d, 0x10, 0xf5, 0x07, 0x36, 0x2e, 0x32,
						0x2d, 0xe3, 0x68, 0x57, 0x93, 0x65, 0xd2, 0x86,
						0x2b, 0x50, 0xed,
					},
				},
			},
		},
	}
	ikeMessage.Payloads = ikePayloads

	// Successful encryption
	err = encryptMsg(ikeMessage, ikeSAKey, message.Role_Initiator)
	require.NoError(t, err)

	rawMsg, err := ikeMessage.Encode()
	require.NoError(t, err)

	expectedIkeMsg, err := decryptMsg(
		rawMsg, ikeMessage, ikeSAKey, message.Role_Responder)
	require.NoError(t, err)
	require.Equal(t, expectedIkeMsg, ikeMessage)

	// IKE Security Association is nil
	err = encryptMsg(ikeMessage, nil, message.Role_Initiator)
	require.Error(t, err)

	// No IKE payload to be encrypted
	ikeMessage.Payloads.Reset()
	err = encryptMsg(ikeMessage, ikeSAKey, message.Role_Initiator)
	require.Error(t, err)
	ikeMessage.Payloads = ikePayloads

	// Response IKE Message is nil
	err = encryptMsg(nil, ikeSAKey, message.Role_Initiator)
	require.Error(t, err)

	// No integrity algorithm specified
	ikeSAKey.IntegInfo = nil
	err = encryptMsg(ikeMessage, ikeSAKey, message.Role_Initiator)
	require.Error(t, err)

	ikeSAKey.IntegInfo = integrityAlgorithm

	// No encryption algorithm specified
	ikeSAKey.EncrInfo = nil
	err = encryptMsg(ikeMessage, ikeSAKey, message.Role_Initiator)
	require.Error(t, err)

	ikeSAKey.EncrInfo = encryptionAlgorithm

	// No responder's integrity key
	ikeSAKey.Integ_r = nil
	err = encryptMsg(ikeMessage, ikeSAKey, message.Role_Initiator)
	require.Error(t, err)

	ikeSAKey.Integ_r = integ_r

	// No responder's encryption key
	ikeSAKey.Encr_r = nil
	err = encryptMsg(ikeMessage, ikeSAKey, message.Role_Initiator)
	require.Error(t, err)
}

func TestVerifyIntegrity(t *testing.T) {
	tests := []struct {
		name          string
		key           string
		originData    []byte
		checksum      string
		ikeSAKey      *security.IKESAKey
		role          message.Role
		expectedValid bool
	}{
		{
			name:       "HMAC MD5 96 - valid",
			key:        "0123456789abcdef0123456789abcdef",
			originData: []byte("hello world"),
			checksum:   "c30f366e411540f68221d04a",
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_MD5_96"),
			},
			role:          message.Role_Responder,
			expectedValid: true,
		},
		{
			name:       "HMAC MD5 96 - invalid checksum",
			key:        "0123456789abcdef0123456789abcdef",
			originData: []byte("hello world"),
			checksum:   "01231875aa",
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_MD5_96"),
			},
			role:          message.Role_Responder,
			expectedValid: false,
		},
		{
			name:       "HMAC MD5 96 - invalid key length",
			key:        "0123",
			originData: []byte("hello world"),
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_MD5_96"),
			},
			role:          message.Role_Responder,
			expectedValid: false,
		},
		{
			name:       "HMAC SHA1 96 - valid",
			key:        "0123456789abcdef0123456789abcdef01234567",
			originData: []byte("hello world"),
			checksum:   "5089f6a86e4dafb89e3fcd23",
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			role:          message.Role_Initiator,
			expectedValid: true,
		},
		{
			name:       "HMAC SHA1 96 - invalid checksum",
			key:        "0123456789abcdef0123456789abcdef01234567",
			originData: []byte("hello world"),
			checksum:   "01231875aa",
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			role:          message.Role_Initiator,
			expectedValid: false,
		},
		{
			name:       "HMAC SHA1 96 - invalid key length",
			key:        "0123",
			originData: []byte("hello world"),
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA1_96"),
			},
			role:          message.Role_Initiator,
			expectedValid: false,
		},
		{
			name:       "HMAC SHA256 128 - valid",
			key:        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			originData: []byte("hello world"),
			checksum:   "a64166565bc1f48eb3edd4109fcaeb72",
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA2_256_128"),
			},
			role:          message.Role_Initiator,
			expectedValid: true,
		},
		{
			name:       "HMAC SHA256 128 - invalid checksum",
			key:        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			originData: []byte("hello world"),
			checksum:   "01231875aa",
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA2_256_128"),
			},
			role:          message.Role_Initiator,
			expectedValid: false,
		},
		{
			name:       "HMAC SHA256 128 - invalid key length",
			key:        "0123",
			originData: []byte("hello world"),
			ikeSAKey: &security.IKESAKey{
				IntegInfo: integ.StrToType("AUTH_HMAC_SHA2_256_128"),
			},
			role:          message.Role_Initiator,
			expectedValid: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var key, checksum []byte
			var err error
			checksum, err = hex.DecodeString(tt.checksum)
			require.NoError(t, err, "failed to decode checksum hex string")

			key, err = hex.DecodeString(tt.key)
			require.NoError(t, err, "failed to decode key hex string")

			integ := tt.ikeSAKey.IntegInfo.Init(key)

			if tt.role == message.Role_Initiator {
				tt.ikeSAKey.Integ_i = integ
			} else {
				tt.ikeSAKey.Integ_r = integ
			}

			err = verifyIntegrity(tt.originData, checksum, tt.ikeSAKey, tt.role)
			if tt.expectedValid {
				require.NoError(t, err, "verifyIntegrity returned an error")
			}
		})
	}
}
